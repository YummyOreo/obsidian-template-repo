/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ShukuchiPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/utils/collections.ts
function sorter(toOrdered, order = "asc") {
  return (a, b) => order === "asc" ? toOrdered(a) > toOrdered(b) ? 1 : toOrdered(b) > toOrdered(a) ? -1 : 0 : toOrdered(a) < toOrdered(b) ? 1 : toOrdered(b) < toOrdered(a) ? -1 : 0;
}
function mirrorMap(collection, toValue) {
  return collection.reduce((p, c) => ({ ...p, [toValue(c)]: toValue(c) }), {});
}
function mirror(collection) {
  return mirrorMap(collection, (x) => x);
}

// src/errors.ts
var ExhaustiveError = class extends Error {
  constructor(value, message = `Unsupported type: ${value}`) {
    super(message);
  }
};

// src/commands.ts
var directionList = ["forward", "both"];
function createCommand(leaf) {
  switch (leaf) {
    case "same-tab":
      return "editor:follow-link";
    case "new-tab":
      return "editor:open-link-in-new-leaf";
    default:
      throw new ExhaustiveError(leaf);
  }
}
function selectTarget(targets, currentOffset, cursor, direction) {
  var _a;
  switch (direction) {
    case "forward":
      return targets.sort(sorter((x) => x.start)).find((x) => x.end >= currentOffset);
    case "both":
      return (_a = targets.sort(
        sorter(
          (x) => Math.min(
            Math.abs(x.start - currentOffset),
            Math.abs(x.end - currentOffset)
          ) + (x.line === cursor.line ? 0 : 1e4)
        )
      )) == null ? void 0 : _a[0];
    default:
      throw new ExhaustiveError(direction);
  }
}
function openLink(appHelper, option) {
  const editor = appHelper.getActiveMarkdownEditor();
  if (!editor) {
    return;
  }
  const linksMatches = Array.from(
    editor.getValue().matchAll(/(?<link>\[\[[^\]]+]])/g)
  );
  const internalLinkPositions = linksMatches.map((x) => ({
    start: x.index,
    end: x.index + x.groups.link.length,
    line: editor.offsetToPos(x.index + 1).line
  }));
  const urlsMatches = Array.from(
    editor.getValue().matchAll(/(^| |\(|\n)(?<url>https?:\/\/[^ )\n]+)/g)
  );
  const externalLinkPositions = urlsMatches.map((x) => ({
    start: x.index,
    end: x.index + x.groups.url.length,
    line: editor.offsetToPos(x.index + 1).line
  }));
  const cursor = editor.getCursor();
  const currentOffset = editor.posToOffset(cursor);
  const target = selectTarget(
    [...internalLinkPositions, ...externalLinkPositions],
    currentOffset,
    cursor,
    option.direction
  );
  if (!target) {
    return;
  }
  if (currentOffset <= target.start || currentOffset > target.end) {
    editor.setCursor(editor.offsetToPos(target.start + 3));
  }
  appHelper.executeCoreCommand(createCommand(option.leaf));
}
function createCommands(appHelper, settings) {
  return [
    {
      id: "open-link",
      name: "Open link",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            openLink(appHelper, {
              leaf: "same-tab",
              direction: settings.directionOfPossibleTeleportation
            });
          }
          return true;
        }
      }
    },
    {
      id: "open-link-in-new-tab",
      name: "Open link in new tab",
      checkCallback: (checking) => {
        if (appHelper.getActiveFile() && appHelper.getActiveMarkdownView()) {
          if (!checking) {
            openLink(appHelper, {
              leaf: "new-tab",
              direction: settings.directionOfPossibleTeleportation
            });
          }
          return true;
        }
      }
    }
  ];
}

// src/settings.ts
var DEFAULT_SETTINGS = {
  directionOfPossibleTeleportation: "both"
};
var ShukuchiSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "General" });
    new import_obsidian.Setting(containerEl).setName("Direction of possible teleportation").addDropdown(
      (cb) => cb.addOptions(mirror([...directionList])).setValue(this.plugin.settings.directionOfPossibleTeleportation).onChange(async (value) => {
        this.plugin.settings.directionOfPossibleTeleportation = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/app-helper.ts
var import_obsidian2 = require("obsidian");
var AppHelper = class {
  constructor(app) {
    this.unsafeApp = app;
  }
  getActiveFile() {
    return this.unsafeApp.workspace.getActiveFile();
  }
  getActiveMarkdownView() {
    return this.unsafeApp.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
  }
  getActiveMarkdownEditor() {
    var _a, _b;
    return (_b = (_a = this.getActiveMarkdownView()) == null ? void 0 : _a.editor) != null ? _b : null;
  }
  executeCoreCommand(command) {
    return this.unsafeApp.commands.executeCommandById(command);
  }
};

// src/main.ts
var ShukuchiPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.appHelper = new AppHelper(this.app);
    this.init();
    createCommands(this.appHelper, this.settings).forEach(
      (c) => this.addCommand(c)
    );
    this.addSettingTab(new ShukuchiSettingTab(this.app, this));
  }
  init() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.init();
  }
};
